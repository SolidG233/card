<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å°æ™ºçš„ç®€æ˜“ç‚‰çŸ³ - æ³•æœ¯ç‰ˆ</title>
<style>
/* --- å…¨å±€æ ·å¼ (ä¿æŒä¸å˜) --- */
body {
    font-family: 'Segoe UI', sans-serif;
    background: url('https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01238_%20%E6%8B%B7%E8%B4%9D.jpg') no-repeat center center fixed;
    background-size: cover;
    color: white;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100vh; margin: 0; overflow: hidden;
}

#game-board {
    width: 900px; height: 650px;
    background-color: rgba(30, 30, 30, 0.9);
    border: 5px solid #5c4033;
    border-radius: 15px;
    display: flex; flex-direction: column; position: relative;
    box-shadow: 0 0 50px rgba(0,0,0,0.9);
    user-select: none;
    backdrop-filter: blur(5px);
}

.zone { flex: 1; display: flex; align-items: center; justify-content: center; border-bottom: 1px solid #444; position: relative; }
.zone:last-child { border-bottom: none; }

.hero-zone { background-color: rgba(0, 0, 0, 0.3); height: 18%; justify-content: space-between; padding: 0 30px; }

.hero {
    width: 95px; height: 95px;
    border-radius: 50%;
    background-color: #333;
    display: flex; align-items: center; justify-content: center;
    font-weight: bold;
    border: 4px solid #f1c40f;
    position: relative; z-index: 2;
    box-shadow: 0 0 15px black;
    text-align: center; font-size: 14px;
    overflow: hidden;
    transition: transform 0.1s;
    flex-shrink: 0;
}

.hero img {
    width: 100%; height: 100%;
    object-fit: cover;
    opacity: 0.8;
    position: absolute; top: 0; left: 0; z-index: -1;
    transition: opacity 0.3s;
}
.hero:hover img { opacity: 1; }

.hero.player { border-color: #3498db; box-shadow: 0 0 15px #3498db; }

/* ç›®æ ‡é«˜äº®æ ·å¼ */
.valid-target:hover { border-color: red !important; box-shadow: 0 0 20px red !important; cursor: crosshair; transform: scale(1.1); }
.valid-target.protected-by-taunt { filter: grayscale(100%); opacity: 0.5; cursor: not-allowed !important; }
.valid-target.protected-by-taunt:hover { border-color: inherit !important; box-shadow: none !important; transform: none !important; }

.stats { font-size: 16px; text-align: center; text-shadow: 2px 2px 2px black; font-weight: bold; min-width: 80px; }

/* --- AI æ‰‹ç‰ŒåŒºåŸŸ --- */
#ai-hand-visual {
    flex: 1; display: flex; justify-content: center; align-items: center; height: 100%; padding: 0 20px; overflow: hidden;
}

/* å¡èƒŒæ ·å¼ */
.card-back {
    width: 50px; height: 75px;
    background-color: #5d4037;
    background-image: url('https://via.placeholder.com/50x75?text=Back');
    background-size: cover; background-position: center;
    border: 2px solid #3e2723; border-radius: 5px;
    margin-left: -25px; box-shadow: -2px 0 5px rgba(0,0,0,0.5);
    transition: transform 0.2s;
}
.card-back:first-child { margin-left: 0; }
.card-back:hover { transform: translateY(-10px); z-index: 10; }

#upload-btn {
    position: absolute; top: -40px; left: 0;
    background: #3498db; color: white;
    border: none; padding: 5px 10px;
    cursor: pointer; border-radius: 5px; font-size: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}
#upload-btn:hover { background: #2980b9; }

.field-zone {
    background: rgba(62, 39, 35, 0.6);
    height: 26%; gap: 10px; padding: 0 20px;
    border-top: 1px solid rgba(255,255,255,0.1);
    border-bottom: 1px solid rgba(0,0,0,0.5);
}

.hand-zone { background-color: rgba(20, 20, 20, 0.5); height: 22%; gap: -20px; padding-bottom: 10px; align-items: flex-end; justify-content: center; }

/* --- å¡ç‰Œæ ·å¼ --- */
.card {
    width: 100px; height: 140px;
    background-color: #ecf0f1; color: #333;
    border-radius: 8px; border: 3px solid #555;
    display: flex; flex-direction: column;
    box-sizing: border-box; cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative; font-size: 12px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
    transform-origin: center center;
}
.card:hover { transform: scale(1.2) translateY(-20px); z-index: 100; border-color: #f39c12; box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
.card.minion-on-field { width: 90px; height: 120px; transform: none; transition: transform 0.1s; }
.card.minion-on-field:hover { transform: scale(1.05); }
.card.disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }

/* ç‰¹æ•ˆå¡ç‰Œæ ·å¼ */
.card.effect-card { border-color: #9b59b6; box-shadow: 0 0 10px #8e44ad; }
.card.deathrattle-card { border-color: #2ecc71; box-shadow: 0 0 10px #27ae60; }
/* æ³•æœ¯ç‰Œæ ·å¼ */
.card.spell-card { border-color: #3498db; box-shadow: 0 0 10px #2980b9; background-color: #e8f6f3; }
.card.spell-card .card-img-container { height: 65%; border-radius: 5px; border-bottom: none; margin: 5px; width: auto; }
.card.spell-card .card-text-area { background: transparent; padding-top: 0; }

/* å˜²è®½å¡ç‰Œæ ·å¼ */
.card.taunt-card {
    border-color: #7f8c8d; border-width: 4px;
    box-shadow: 0 0 0 3px #34495e, 0 0 15px black;
    border-radius: 8px 8px 20px 20px;
}
.card.taunt-card::before {
    content: 'ğŸ›¡ï¸'; position: absolute; top: -15px; right: -10px; font-size: 20px; z-index: 10; text-shadow: 0 0 5px black;
}

.deathrattle-icon { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); font-size: 16px; z-index: 6; text-shadow: 0 0 3px black; }

.card-img-container { width: 100%; height: 55%; background-color: #333; border-bottom: 2px solid #555; overflow: hidden; border-radius: 5px 5px 0 0; }
.card-img { width: 100%; height: 100%; object-fit: cover; }
.card-text-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2px; background: #e0e0e0; border-radius: 0 0 5px 5px; }
.card-name { font-weight: bold; font-size: 11px; text-align: center; margin-bottom: 2px; }
.card-desc { font-size: 9px; color: #555; text-align: center; line-height: 1; padding: 0 2px; }

.stat-bubble { position: absolute; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; color: white; text-shadow: 1px 1px 1px black; border: 2px solid white; z-index: 5; }
.card-cost { top: -8px; left: -8px; background: #3498db; }
.card-atk { bottom: -5px; left: -5px; background: #f39c12; border-radius: 5px; }
.card-hp { bottom: -5px; right: -5px; background: #e74c3c; }

/* --- æ‚¬åœé¢„è§ˆå¡ç‰‡æ ·å¼ (æ–°å¢) --- */
#card-preview {
    position: absolute;
    right: -250px; /* åˆå§‹éšè—åœ¨å³ä¾§ */
    top: 100px;
    width: 220px;
    height: 320px;
    background-color: #ecf0f1;
    border: 5px solid #333;
    border-radius: 15px;
    box-shadow: 0 0 30px rgba(0,0,0,0.8);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    pointer-events: none; /* ä¸å¹²æ‰°é¼ æ ‡ç‚¹å‡» */
    transition: opacity 0.2s, transform 0.2s;
    opacity: 0;
    transform: translateX(20px);
    color: #333;
}

#card-preview.visible {
    opacity: 1;
    transform: translateX(0);
    right: -250px; /* æ˜¾ç¤ºæ—¶ä½ç½® */
}

#card-preview .card-img-container { height: 60%; border-radius: 10px 10px 0 0; }
#card-preview .card-text-area { padding: 15px; font-size: 14px; border-radius: 0 0 10px 10px; justify-content: flex-start; }
#card-preview .card-name { font-size: 20px; margin-bottom: 10px; border-bottom: 2px solid #ccc; width: 100%; padding-bottom: 5px; }
#card-preview .card-desc { font-size: 16px; line-height: 1.4; color: #2c3e50; }
#card-preview .stat-bubble { width: 40px; height: 40px; font-size: 24px; border-width: 3px; }
#card-preview .card-cost { top: -15px; left: -15px; }
#card-preview .card-atk { bottom: -10px; left: -10px; }
#card-preview .card-hp { bottom: -10px; right: -10px; }
/* é¢„è§ˆæ¡†çš„ç‰¹æ®Šæ ·å¼ */
#card-preview.spell-card { background-color: #e8f6f3; border-color: #3498db; }
#card-preview.taunt-card { border-color: #7f8c8d; }

/* åŠ¨ç”»ä¸ç‰¹æ•ˆ (ä¿æŒä¸å˜) */
@keyframes pulse-green {
    0% { box-shadow: 0 0 5px #2ecc71; border-color: #27ae60; }
    50% { box-shadow: 0 0 20px #2ecc71, 0 0 10px #2ecc71 inset; border-color: #2ecc71; transform: scale(1.02); }
    100% { box-shadow: 0 0 5px #2ecc71; border-color: #27ae60; }
}
.can-attack { animation: pulse-green 1.5s infinite ease-in-out !important; cursor: grab; z-index: 10; }
.can-attack:active { cursor: grabbing; animation: none !important; box-shadow: 0 0 25px #f1c40f !important; }

#turn-btn { padding: 10px 25px; background: linear-gradient(to bottom, #f1c40f, #f39c12); border: 2px solid #d35400; color: #5d4037; border-radius: 20px; font-weight: bold; cursor: pointer; font-size: 16px; box-shadow: 0 4px 0 #d35400; transition: active 0.1s; }
#turn-btn:active { transform: translateY(4px); box-shadow: none; }
#turn-btn:disabled { background: #95a5a6; border-color: #7f8c8d; color: #bdc3c7; box-shadow: none; cursor: not-allowed; }
#log-area { position: absolute; left: -220px; top: 0; width: 200px; height: 300px; background: rgba(0,0,0,0.7); color: #fff; font-size: 13px; overflow-y: auto; padding: 10px; pointer-events: none; border-radius: 5px; z-index: 50; border: 1px solid #555; font-family: monospace; }
.mana-display { font-weight: bold; color: #3498db; text-shadow: 0 0 5px #3498db; font-size: 18px; margin-bottom: 5px;}

#drag-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; display: none; }
#drag-line { stroke: #e74c3c; stroke-width: 4; stroke-linecap: round; stroke-dasharray: 10 5; }
#drag-target-circle { fill: none; stroke: #e74c3c; stroke-width: 3; }
/* æ³•æœ¯æ‹–æ‹½æ—¶çš„çº¿æ¡é¢œè‰² */
.spell-drag #drag-line { stroke: #3498db; }
.spell-drag #drag-target-circle { stroke: #3498db; }

@keyframes shake-anim { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
.shaking { animation: shake-anim 0.5s; border-color: red !important; }
@keyframes float-up { 0% { opacity: 1; transform: translateY(0) scale(1); } 50% { opacity: 1; transform: translateY(-30px) scale(1.5); } 100% { opacity: 0; transform: translateY(-60px) scale(1); } }
.damage-text { position: absolute; color: #ff3333; font-size: 32px; font-weight: 900; text-shadow: 2px 2px 0 #000, -1px -1px 0 #fff; pointer-events: none; z-index: 999; animation: float-up 1s forwards; }
@keyframes slash-anim { 0% { width: 0; opacity: 0.8; } 50% { width: 120px; opacity: 1; } 100% { width: 140px; opacity: 0; } }
.slash-effect { position: absolute; height: 4px; background: white; box-shadow: 0 0 10px 2px red; transform: rotate(-45deg); z-index: 500; pointer-events: none; animation: slash-anim 0.3s ease-out forwards; }
.slash-effect::after { content: ''; position: absolute; top: 0; left: 50%; width: 100%; height: 100%; background: white; box-shadow: 0 0 10px 2px red; transform: rotate(90deg) translateX(-50%); }
@keyframes ripple-anim { 0% { transform: scale(0); opacity: 0.8; } 100% { transform: scale(4); opacity: 0; } }
.ripple-effect { position: absolute; width: 100px; height: 100px; background: radial-gradient(circle, rgba(255,0,0,0.5) 0%, rgba(255,0,0,0) 70%); border-radius: 50%; pointer-events: none; z-index: 400; animation: ripple-anim 0.6s ease-out forwards; }
@keyframes skull-anim { 0% { opacity: 0; transform: scale(0.5); } 50% { opacity: 1; transform: scale(1.2); } 100% { opacity: 0; transform: scale(1.5) translateY(-20px); } }
.deathrattle-effect { position: absolute; font-size: 40px; z-index: 999; pointer-events: none; animation: skull-anim 1s forwards; text-shadow: 0 0 10px black; }

/* æ³•æœ¯çˆ†ç‚¸ç‰¹æ•ˆ */
@keyframes explosion-anim { 0% { transform: scale(0.5); opacity: 1; } 50% { transform: scale(2); opacity: 0.8; background: radial-gradient(circle, #f1c40f, #e74c3c); } 100% { transform: scale(3); opacity: 0; } }
.spell-explosion { position: absolute; width: 80px; height: 80px; border-radius: 50%; background: radial-gradient(circle, #3498db, #2980b9); z-index: 999; pointer-events: none; animation: explosion-anim 0.5s ease-out forwards; box-shadow: 0 0 20px white; }

</style>
</head>
<body>

<div id="game-board">
    <button id="upload-btn" onclick="document.getElementById('card-back-input').click()">ğŸ“· æ›´æ¢å¯¹æ‰‹å¡èƒŒ</button>
    <input type="file" id="card-back-input" accept="image/*" style="display: none;" onchange="uploadCardBack(this)">

    <!-- æ‚¬åœé¢„è§ˆåŒºåŸŸ (æ–°å¢) -->
    <div id="card-preview">
        <!-- å†…å®¹å°†ç”±JSåŠ¨æ€å¡«å…… -->
    </div>

    <svg id="drag-svg">
        <line id="drag-line" x1="0" y1="0" x2="0" y2="0" />
        <circle id="drag-target-circle" cx="0" cy="0" r="15" />
    </svg>

    <div id="log-area"></div>

    <div class="zone hero-zone">
        <div class="stats">
            <div class="mana-display">ğŸ’ <span id="ai-mana">0/0</span></div>
        </div>

        <div id="ai-hand-visual"></div>

        <div class="hero valid-target" id="ai-hero-visual" data-target-type="hero" data-side="ai">
            <img src="https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01224_%20%E6%8B%B7%E8%B4%9D.jpg" alt="AI">
            <span style="position:relative; z-index:2;">AI<br>â¤ï¸ <span id="ai-health">30</span></span>
        </div>
    </div>

    <div class="zone field-zone" id="ai-field"></div>
    <div class="zone field-zone" id="player-field"></div>

    <div class="zone hero-zone">
        <div class="hero player" id="player-hero-visual">
            <img src="https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01230_%20%E6%8B%B7%E8%B4%9D.jpg" alt="Player">
            <span style="position:relative; z-index:2;">æˆ‘<br>â¤ï¸ <span id="player-health">30</span></span>
        </div>
        <div class="stats" style="display:flex; flex-direction:column; align-items:flex-end;">
            <div class="mana-display">ğŸ’ <span id="player-mana">0/0</span></div>
            <button id="turn-btn" onclick="endTurn()">ç»“æŸå›åˆ</button>
        </div>
    </div>

    <div class="zone hand-zone" id="player-hand"></div>
</div>

<script>
const GAME_STATE = {
    turn: 1, isPlayerTurn: true,
    player: { health: 30, maxMana: 0, currentMana: 0, hand: [], field: [], deck: [] },
    ai: { health: 30, maxMana: 0, currentMana: 0, hand: [], field: [], deck: [] }
};

let isDragging = false;
let dragSourceId = null;
let dragSourceType = null; // 'field' or 'hand_spell'
let dragStartX = 0;
let dragStartY = 0;

let currentCardBack = 'https://via.placeholder.com/50x75?text=Back';

function uploadCardBack(input) {
    if (input.files && input.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
            currentCardBack = e.target.result;
            updateUI();
            log("å¯¹æ‰‹å¡èƒŒå·²æ›´æ¢ï¼");
        }
        reader.readAsDataURL(input.files[0]);
    }
}

const CARD_DB = [
    { name: "è¯»ä¹¦å°ç‹—", cost: 1, atk: 1, hp: 1, desc: "å¯çˆ±ä½†è„†å¼±", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01553_%20%E6%8B%B7%E8%B4%9D.jpg" },
    { name: "é«˜é›…è¯»ä¹¦äºº", cost: 1, atk: 2, hp: 1, desc: "å“‡å•¦å“‡å•¦ï¼", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01549_%20%E6%8B%B7%E8%B4%9D.jpg" },
    { name: "è¯»ä¹¦æ°´ç­", cost: 2, atk: 3, hp: 2, desc: "é‡å…½",img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01554_%20%E6%8B%B7%E8%B4%9D.jpg"},
    { name: "æœºè½¦è¯»ä¹¦äºº", cost: 3, atk: 3, hp: 3, desc: "å˜²è®½", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01566_%20%E6%8B%B7%E8%B4%9D.jpg", taunt: true },
    { name: "æ„¤æ€’è¯»ä¹¦äºº", cost: 4, atk: 6, hp: 3, desc: "é«˜æ”»ä½è¡€",img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01568_%20%E6%8B%B7%E8%B4%9D.jpg"},
    { name: "è¯»ä¹¦æ¾é¼ ", cost: 4, atk: 4, hp: 5, desc: "ç»“å®çš„èº«æ¿",img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01419_%20%E6%8B%B7%E8%B4%9D.jpg" },
    { name: "è¯»ä¹¦å·¨äºº", cost: 6, atk: 6, hp: 7, desc: "èº«ææå¥½", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01551_%20%E6%8B%B7%E8%B4%9D.jpg" },
    { name: "ç†¬å¤œè¯»ä¹¦äºº", cost: 7, atk: 9, hp: 5, desc: "åŒå¤´æ€ªå…½", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_01555_%20%E6%8B%B7%E8%B4%9D.jpg" },
    { name: "æš´èºç®¡ç†å‘˜", cost: 3, atk: 2, hp: 2, desc: "æˆ˜å¼ï¼šå…¨åœºæ‰“1", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_00878_%20%E6%8B%B7%E8%B4%9D.jpg", effect: "aoe_1" },
    { name: "è‡ªçˆ†è¯»ä¹¦äºº", cost: 2, atk: 2, hp: 1, desc: "äº¡è¯­ï¼šéšæœºæ‰“2", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ComfyUI_00946_%20%E6%8B%B7%E8%B4%9D.jpg", deathrattle: "random_2" },
    // --- æ³•æœ¯ç‰Œ ---
    { name: "ç»ˆæçˆ†ç ´", cost: 4, type: 'spell', desc: "å¯¹ä¸€ä¸ªè§’è‰²é€ æˆ6ç‚¹ä¼¤å®³", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ScreenShot_2025-12-03_162106_910%20%E6%8B%B7%E8%B4%9D.jpg", effect: "damage_6" },
    // --- æ–°å¢ï¼šè¯»ä¹¦æ™ºæ…§ ---
    { name: "è¯»ä¹¦æ™ºæ…§", cost: 3, type: 'spell', desc: "æŠ½2å¼ ç‰Œ", img: "https://raw.githubusercontent.com/SolidG233/https-github.com-SolidG233/refs/heads/main/ScreenShot_2025-12-03_164822_263%20%E6%8B%B7%E8%B4%9D.jpg", effect: "draw_2" }
];

function initGame() {
    createDeck(GAME_STATE.player.deck);
    createDeck(GAME_STATE.ai.deck);
    drawCard('player', 3);
    drawCard('ai', 3);
    startTurn();
    initDragSystem();
}

function initDragSystem() {
    const svg = document.getElementById('drag-svg');
    const line = document.getElementById('drag-line');
    const circle = document.getElementById('drag-target-circle');
    const board = document.getElementById('game-board');

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const boardRect = board.getBoundingClientRect();
        const mouseX = e.clientX - boardRect.left;
        const mouseY = e.clientY - boardRect.top;
        line.setAttribute('x2', mouseX);
        line.setAttribute('y2', mouseY);
        circle.setAttribute('cx', mouseX);
        circle.setAttribute('cy', mouseY);
    });

    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        svg.style.display = 'none';
        svg.classList.remove('spell-drag'); // æ¸…é™¤æ³•æœ¯æ‹–æ‹½æ ·å¼
        isDragging = false;

        document.querySelectorAll('.valid-target').forEach(el => el.classList.remove('protected-by-taunt'));

        const targetEl = document.elementFromPoint(e.clientX, e.clientY);
        const validTarget = targetEl ? targetEl.closest('.valid-target') : null;

        if (validTarget) {
            const targetType = validTarget.getAttribute('data-target-type');
            const targetId = validTarget.id;
            const targetSide = validTarget.getAttribute('data-side');

            if (targetSide === 'ai') {
                // 1. éšä»æ”»å‡»é€»è¾‘
                if (dragSourceType === 'field') {
                    const hasTaunt = GAME_STATE.ai.field.some(c => c.taunt);
                    let isTargetTaunt = false;
                    if (targetType === 'minion') {
                        const targetCard = GAME_STATE.ai.field.find(c => c.id === targetId);
                        if (targetCard && targetCard.taunt) isTargetTaunt = true;
                    }

                    if (hasTaunt && !isTargetTaunt) {
                        log("ğŸ›¡ï¸ å¿…é¡»å…ˆæ”»å‡»å…·æœ‰å˜²è®½çš„éšä»ï¼");
                    } else {
                        attack(dragSourceId, targetType, targetId);
                    }
                }
                // 2. æ³•æœ¯é‡Šæ”¾é€»è¾‘
                else if (dragSourceType === 'hand_spell') {
                     // æ³•æœ¯é€šå¸¸æ— è§†å˜²è®½
                     castTargetedSpell(dragSourceId, targetType, targetId);
                }
            }
        }
    });
}

function startDrag(e, cardId, type) {
    if (!GAME_STATE.isPlayerTurn) return;

    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‹–æ‹½
    if (type === 'field') {
        const card = GAME_STATE.player.field.find(c => c.id === cardId);
        if (!card || !card.canAttack) return;
    } else if (type === 'hand_spell') {
        const card = GAME_STATE.player.hand.find(c => c.id === cardId);
        if (!card || GAME_STATE.player.currentMana < card.cost) {
            log("æ³•åŠ›å€¼ä¸è¶³ï¼");
            return;
        }
    }

    e.preventDefault();
    isDragging = true;
    dragSourceId = cardId;
    dragSourceType = type;

    const board = document.getElementById('game-board');
    const boardRect = board.getBoundingClientRect();
    const cardRect = e.currentTarget.getBoundingClientRect();
    dragStartX = (cardRect.left + cardRect.width / 2) - boardRect.left;
    dragStartY = (cardRect.top + cardRect.height / 2) - boardRect.top;

    const svg = document.getElementById('drag-svg');
    const line = document.getElementById('drag-line');
    const circle = document.getElementById('drag-target-circle');

    // å¦‚æœæ˜¯æ³•æœ¯ï¼Œæ”¹å˜æ‹–æ‹½çº¿é¢œè‰²
    if (type === 'hand_spell') {
        svg.classList.add('spell-drag');
    }

    line.setAttribute('x1', dragStartX);
    line.setAttribute('y1', dragStartY);
    line.setAttribute('x2', dragStartX);
    line.setAttribute('y2', dragStartY);
    circle.setAttribute('cx', dragStartX);
    circle.setAttribute('cy', dragStartY);
    svg.style.display = 'block';

    // éšä»æ”»å‡»æ—¶æ‰æ˜¾ç¤ºå˜²è®½ä¿æŠ¤ï¼Œæ³•æœ¯ä¸æ˜¾ç¤º
    if (type === 'field') {
        const hasTaunt = GAME_STATE.ai.field.some(c => c.taunt);
        if (hasTaunt) {
            const aiHero = document.getElementById('ai-hero-visual');
            aiHero.classList.add('protected-by-taunt');
            GAME_STATE.ai.field.forEach(minion => {
                if (!minion.taunt) {
                    const el = document.getElementById(minion.id);
                    if (el) el.classList.add('protected-by-taunt');
                }
            });
        }
    }
}

function createDeck(deckArray) {
    for(let i=0; i<20; i++) {
        const randomCard = CARD_DB[Math.floor(Math.random() * CARD_DB.length)];
        deckArray.push({...randomCard, id: 'c-' + Math.random().toString(36).substr(2, 9), canAttack: false});
    }
}

function startTurn() {
    const actor = GAME_STATE.isPlayerTurn ? GAME_STATE.player : GAME_STATE.ai;
    const actorName = GAME_STATE.isPlayerTurn ? 'player' : 'ai';
    if (actor.maxMana < 10) actor.maxMana++;
    actor.currentMana = actor.maxMana;
    drawCard(actorName, 1);
    actor.field.forEach(minion => minion.canAttack = true);
    log(`--- ${GAME_STATE.isPlayerTurn ? "ä½ çš„" : "AI"} å›åˆ ---`);
    updateUI();

    if (!GAME_STATE.isPlayerTurn) {
        document.getElementById('turn-btn').disabled = true;
        setTimeout(aiPlay, 1000);
    } else {
        document.getElementById('turn-btn').disabled = false;
    }
}

function endTurn() {
    if (!GAME_STATE.isPlayerTurn) return;
    GAME_STATE.isPlayerTurn = false;
    startTurn();
}

function drawCard(who, count) {
    const actor = GAME_STATE[who];
    for(let i=0; i<count; i++) {
        if (actor.deck.length > 0 && actor.hand.length < 10) {
            actor.hand.push(actor.deck.pop());
        } else if (actor.deck.length === 0) {
            actor.health -= 1;
            log("ç–²åŠ³ä¼¤å®³ï¼ -1è¡€");
            checkGameOver();
        }
    }
    updateUI();
}

// éšä»ç‰Œç‚¹å‡»æ‰“å‡º (åŒ…å«éæŒ‡å‘æ€§æ³•æœ¯é€»è¾‘)
async function playCard(cardId) {
    if (!GAME_STATE.isPlayerTurn) return;
    const cardIndex = GAME_STATE.player.hand.findIndex(c => c.id === cardId);
    if (cardIndex === -1) return;
    const card = GAME_STATE.player.hand[cardIndex];

    // 1. æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦æ‹–æ‹½çš„æ³•æœ¯ (å¦‚é€ æˆä¼¤å®³)
    if (card.type === 'spell' && card.effect !== 'draw_2') {
        log("è¯·æ‹–åŠ¨æ³•æœ¯ç‰Œåˆ°ç›®æ ‡èº«ä¸Šï¼");
        return;
    }

    if (GAME_STATE.player.currentMana >= card.cost) {
        // 2. å¤„ç†æŠ½ç‰Œæ³•æœ¯ (è¯»ä¹¦æ™ºæ…§)
        if (card.type === 'spell' && card.effect === 'draw_2') {
            GAME_STATE.player.currentMana -= card.cost;
            GAME_STATE.player.hand.splice(cardIndex, 1);
            log(`ä½ ä½¿ç”¨äº† [${card.name}]`);
            drawCard('player', 2);
            updateUI();
            return; // æ³•æœ¯å¤„ç†å®Œæ¯•ï¼Œç›´æ¥è¿”å›
        }

        // 3. å¤„ç†éšä»ç‰Œ
        if (GAME_STATE.player.field.length < 7) {
            GAME_STATE.player.currentMana -= card.cost;
            GAME_STATE.player.hand.splice(cardIndex, 1);
            GAME_STATE.player.field.push(card);
            log(`ä½ æ‰“å‡ºäº† [${card.name}]`);
            updateUI();

            if (card.effect === 'aoe_1') {
                await triggerCardEffect(card);
            }
        } else {
            log("æˆ˜åœºå·²æ»¡ï¼");
        }

    } else {
        log("æ³•åŠ›ä¸è¶³ï¼");
    }
}

// æ³•æœ¯é‡Šæ”¾é€»è¾‘ (æŒ‡å‘æ€§)
async function castTargetedSpell(cardId, targetType, targetId) {
    const cardIndex = GAME_STATE.player.hand.findIndex(c => c.id === cardId);
    if (cardIndex === -1) return;
    const card = GAME_STATE.player.hand[cardIndex];

    if (GAME_STATE.player.currentMana >= card.cost) {
        GAME_STATE.player.currentMana -= card.cost;
        GAME_STATE.player.hand.splice(cardIndex, 1);

        let targetName = "";
        let targetObj = null;

        if (targetType === 'hero') {
            targetObj = GAME_STATE.ai;
            targetName = "AIè‹±é›„";
            // è§†è§‰ç›®æ ‡ID
            await playSpellEffect('ai-hero-visual');
            targetObj.health -= 6;
        } else {
            targetObj = GAME_STATE.ai.field.find(c => c.id === targetId);
            if(targetObj) {
                targetName = targetObj.name;
                await playSpellEffect(targetId);
                targetObj.hp -= 6;
            }
        }

        log(`ğŸ’¥ ä½ å¯¹ ${targetName} æ–½æ”¾äº† ${card.name}ï¼Œé€ æˆ6ç‚¹ä¼¤å®³ï¼`);
        updateUI();
        await cleanDeadMinions();
        checkGameOver();
    }
}

// æ³•æœ¯ç‰¹æ•ˆ
async function playSpellEffect(elementId) {
    return new Promise(resolve => {
        const el = document.getElementById(elementId);
        if (!el) { resolve(); return; }

        const explosion = document.createElement('div');
        explosion.className = 'spell-explosion';
        const rect = el.getBoundingClientRect();
        // å±…ä¸­æ˜¾ç¤º
        explosion.style.left = (rect.left + rect.width/2 - 40) + 'px';
        explosion.style.top = (rect.top + rect.height/2 - 40) + 'px';
        document.body.appendChild(explosion);

        playHitEffect(elementId, 6); // åŒæ—¶æ’­æ”¾éœ‡åŠ¨å’Œæ•°å­—

        setTimeout(() => {
            explosion.remove();
            resolve();
        }, 500);
    });
}

async function triggerCardEffect(sourceCard) {
    if (sourceCard.effect === 'aoe_1') {
        log(`âš¡ ${sourceCard.name} å¤§å¼ä¸€å£°ï¼šå®‰é™ï¼(å…¨åœºæ‰“1)`);
        const cardEl = document.getElementById(sourceCard.id);
        if(cardEl) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple-effect';
            ripple.style.left = '0'; ripple.style.top = '0';
            cardEl.appendChild(ripple);
            await sleep(300);
        }

        const allMinions = [...GAME_STATE.player.field, ...GAME_STATE.ai.field];
        const hitPromises = allMinions.map(async (minion) => {
            if (minion.id !== sourceCard.id) {
                minion.hp -= 1;
                await playHitEffect(minion.id, 1);
            }
        });

        await Promise.all(hitPromises);
        await cleanDeadMinions();
        updateUI();
    }
}

async function triggerDeathrattle(deadCard) {
    if (deadCard.deathrattle === 'random_2') {
        log(`â˜ ï¸ ${deadCard.name} è§¦å‘äº¡è¯­ï¼šéšæœºé€ æˆ2ç‚¹ä¼¤å®³ï¼`);

        const cardEl = document.getElementById(deadCard.id);
        if (cardEl) {
            const skull = document.createElement('div');
            skull.className = 'deathrattle-effect';
            skull.innerText = 'â˜ ï¸';
            skull.style.left = '25px'; skull.style.top = '30px';
            cardEl.appendChild(skull);
            await sleep(800);
        }

        const isPlayerCard = GAME_STATE.player.field.some(c => c.id === deadCard.id);
        let targets = [];

        if (isPlayerCard) {
            targets.push({ type: 'hero', side: 'ai', data: GAME_STATE.ai, id: 'ai-hero-visual' });
            GAME_STATE.ai.field.forEach(m => {
                if (m.id !== deadCard.id && m.hp > 0) targets.push({ type: 'minion', data: m, id: m.id });
            });
        } else {
            targets.push({ type: 'hero', side: 'player', data: GAME_STATE.player, id: 'player-hero-visual' });
            GAME_STATE.player.field.forEach(m => {
                if (m.id !== deadCard.id && m.hp > 0) targets.push({ type: 'minion', data: m, id: m.id });
            });
        }

        if (targets.length > 0) {
            const target = targets[Math.floor(Math.random() * targets.length)];
            const targetName = target.type === 'hero' ? (target.side === 'player' ? 'ä½ çš„è‹±é›„' : 'AIè‹±é›„') : target.data.name;
            log(`ğŸ’¥ ç‚¸å¼¹é£å‘äº†æ•Œæ–¹ï¼š${targetName}`);

            await playHitEffect(target.id, 2);

            if (target.type === 'hero') {
                target.data.health -= 2;
            } else {
                target.data.hp -= 2;
            }
            updateUI();
        }
    }
}

async function animateCardCollision(attackerId, targetId) {
    const attackerEl = document.getElementById(attackerId);
    const targetEl = document.getElementById(targetId);
    if (!attackerEl || !targetEl) return;

    const aRect = attackerEl.getBoundingClientRect();
    const tRect = targetEl.getBoundingClientRect();
    const aCenterX = aRect.left + aRect.width / 2;
    const aCenterY = aRect.top + aRect.height / 2;
    const tCenterX = tRect.left + tRect.width / 2;
    const tCenterY = tRect.top + tRect.height / 2;
    const deltaX = tCenterX - aCenterX;
    const deltaY = tCenterY - aCenterY;

    const originalZIndex = attackerEl.style.zIndex;
    const originalTransition = attackerEl.style.transition;
    attackerEl.style.zIndex = "1000";
    attackerEl.style.transition = "transform 0.2s cubic-bezier(0.3, 0.0, 0.8, 0.2)";
    attackerEl.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.2)`;

    await sleep(200);
    attackerEl.style.transition = "transform 0.4s ease-out";
    attackerEl.style.transform = "translate(0, 0) scale(1)";
    await sleep(400);

    attackerEl.style.zIndex = originalZIndex;
    attackerEl.style.transition = originalTransition;
}

async function attack(attackerId, targetType, targetId) {
    const attacker = GAME_STATE.player.field.find(c => c.id === attackerId);
    if (!attacker || !attacker.canAttack) return;

    let target = targetType === 'hero' ? GAME_STATE.ai : GAME_STATE.ai.field.find(c => c.id === targetId);
    if (!target) return;

    attacker.canAttack = false;
    const attackerEl = document.getElementById(attackerId);
    if(attackerEl) attackerEl.classList.remove('can-attack');

    const targetDomId = (targetType === 'hero') ? 'ai-hero-visual' : targetId;
    await animateCardCollision(attackerId, targetDomId);

    updateUI();
    await performCombat(attacker, target, targetType === 'hero');
    checkGameOver();
}

async function performCombat(attacker, target, targetIsHero) {
    let targetDomId;
    if (targetIsHero) {
        targetDomId = (target === GAME_STATE.player) ? 'player-hero-visual' : 'ai-hero-visual';
    } else {
        targetDomId = target.id;
    }
    let attackerDomId = attacker.id;

    log(`${attacker.name} æ”»å‡»äº† ${targetIsHero ? "è‹±é›„" : target.name}`);

    await playHitEffect(targetDomId, attacker.atk);

    target.health = (target.health || target.hp) - attacker.atk;
    if (!targetIsHero) target.hp = target.health;

    if (!targetIsHero) {
        if (target.atk > 0) {
            log(`${attacker.name} å—åˆ° ${target.atk} ç‚¹åä¼¤`);
            await playHitEffect(attackerDomId, target.atk);
            attacker.hp -= target.atk;
        }
    }

    await cleanDeadMinions();
    updateUI();
}

async function playHitEffect(elementId, damageAmount) {
    return new Promise(resolve => {
        const el = document.getElementById(elementId);
        if (!el) { resolve(); return; }
        el.classList.add('shaking');
        const slash = document.createElement('div');
        slash.className = 'slash-effect';
        const rect = el.getBoundingClientRect();
        slash.style.left = (rect.left + rect.width/2 - 60) + 'px';
        slash.style.top = (rect.top + rect.height/2) + 'px';
        document.body.appendChild(slash);
        const dmgText = document.createElement('div');
        dmgText.className = 'damage-text';
        dmgText.innerText = "-" + damageAmount;
        dmgText.style.left = (rect.left + rect.width/2 - 10) + 'px';
        dmgText.style.top = (rect.top) + 'px';
        document.body.appendChild(dmgText);
        setTimeout(() => {
            el.classList.remove('shaking');
            slash.remove();
            dmgText.remove();
            resolve();
        }, 600);
    });
}

async function cleanDeadMinions() {
    let hasDeaths = false;
    const deadPlayerMinions = GAME_STATE.player.field.filter(c => c.hp <= 0);
    const deadAiMinions = GAME_STATE.ai.field.filter(c => c.hp <= 0);
    const allDead = [...deadPlayerMinions, ...deadAiMinions];

    if (allDead.length > 0) {
        hasDeaths = true;
        log(`ğŸ’€ ${allDead.length} ä¸ªéšä»é˜µäº¡äº†`);

        for (const deadCard of allDead) {
            if (deadCard.deathrattle) {
                await triggerDeathrattle(deadCard);
            }
        }

        GAME_STATE.player.field = GAME_STATE.player.field.filter(c => c.hp > 0);
        GAME_STATE.ai.field = GAME_STATE.ai.field.filter(c => c.hp > 0);

        updateUI();
        await cleanDeadMinions();
    }
}

function checkGameOver() {
    if (GAME_STATE.player.health <= 0) { alert("å¤±è´¥ï¼"); location.reload(); }
    else if (GAME_STATE.ai.health <= 0) { alert("èƒœåˆ©ï¼"); location.reload(); }
}

async function aiPlay() {
    const ai = GAME_STATE.ai;
    const player = GAME_STATE.player;

    // 1. --- æ–©æ€è®¡ç®—é˜¶æ®µ (Lethal Check) ---
    let boardDamage = ai.field.filter(m => m.canAttack).reduce((sum, m) => sum + m.atk, 0);
    let handSpellDamage = ai.hand.filter(c => c.type === 'spell' && c.effect === 'damage_6' && c.cost <= ai.currentMana)
        .reduce((sum, c) => sum + 6, 0);

    const totalDamage = boardDamage + handSpellDamage;
    const enemyHasTaunt = player.field.some(m => m.taunt);
    const isLethal = (!enemyHasTaunt && totalDamage >= player.health);

    if (isLethal) {
        log("ğŸ¤– AIæ£€æµ‹åˆ°æ–©æ€çº¿ï¼å…¨å†›å‡ºå‡»ï¼");
    }

    // 2. --- å‡ºç‰Œé˜¶æ®µ (Play Cards) ---
    for (let i = ai.hand.length - 1; i >= 0; i--) {
        const card = ai.hand[i];

        // ä¼˜å…ˆä½¿ç”¨æŠ½ç‰Œæ³•æœ¯ (è¯»ä¹¦æ™ºæ…§)
        if (card.type === 'spell' && card.effect === 'draw_2' && ai.currentMana >= card.cost) {
            ai.currentMana -= card.cost;
            ai.hand.splice(i, 1);
            log(`AI ä½¿ç”¨äº† ${card.name}ï¼Œè¡¥å……äº†æ‰‹ç‰Œ`);
            drawCard('ai', 2);
            updateUI();
            continue; // ç»§ç»­å¾ªç¯
        }

        // ä½¿ç”¨ä¼¤å®³æ³•æœ¯
        if (card.type === 'spell' && card.effect === 'damage_6' && ai.currentMana >= card.cost) {
            let targetId = null;
            let targetType = 'hero';

            if (isLethal || player.field.length === 0) {
                targetId = 'player-hero-visual';
                targetType = 'hero';
            } else {
                const threat = player.field.sort((a, b) => b.atk - a.atk).find(m => m.hp <= 6);
                if (threat && threat.atk >= 4) {
                    targetId = threat.id;
                    targetType = 'minion';
                    log(`ğŸ¤– AI å†³å®šç”¨æ³•æœ¯ç§»é™¤å¨èƒï¼š${threat.name}`);
                } else {
                    targetId = 'player-hero-visual';
                    targetType = 'hero';
                }
            }

            if (targetId) {
                await sleep(500);
                ai.currentMana -= card.cost;
                ai.hand.splice(i, 1);

                if (targetType === 'hero') {
                    log(`AI ä½¿ç”¨äº† ${card.name}ï¼Œè½°ç‚¸ä½ çš„è‹±é›„ï¼`);
                    await playSpellEffect('player-hero-visual');
                    player.health -= 6;
                } else {
                    const targetMinion = player.field.find(m => m.id === targetId);
                    if (targetMinion) {
                        log(`AI ä½¿ç”¨ ${card.name} è§£æ‰äº† ${targetMinion.name}`);
                        await playSpellEffect(targetId);
                        targetMinion.hp -= 6;
                    }
                }
                updateUI();
                await cleanDeadMinions();
                checkGameOver();
            }
        }
    }

    // å†å¤„ç†æ‰‹ç‰Œä¸­çš„éšä» (æŒ‰è´¹ç”¨ä»é«˜åˆ°ä½ï¼Œè´ªå©ªé“ºåœº)
    ai.hand.sort((a, b) => b.cost - a.cost);
    for (let i = ai.hand.length - 1; i >= 0; i--) {
        const card = ai.hand[i];
        if (card.type !== 'spell' && ai.currentMana >= card.cost && ai.field.length < 7) {
            await sleep(600);
            ai.currentMana -= card.cost;
            ai.field.push(card);
            ai.hand.splice(i, 1);
            log(`AI å¬å”¤äº† ${card.name}`);
            updateUI();
            if (card.effect === 'aoe_1') await triggerCardEffect(card);
        }
    }

    // 3. --- éšä»æ”»å‡»é˜¶æ®µ (Minion Attacks) ---
    const attackers = ai.field.filter(m => m.canAttack && m.hp > 0);

    for (const minion of attackers) {
        if (minion.hp <= 0) continue;
        await sleep(800);

        const tauntMinions = player.field.filter(m => m.taunt && m.hp > 0);
        const highThreatMinions = player.field.filter(m => m.atk >= 5 && m.hp > 0);

        let target = null;
        let isHero = false;

        if (tauntMinions.length > 0) {
            target = tauntMinions.sort((a, b) => a.hp - b.hp)[0];
            log(`ğŸ¤– AI è¯•å›¾çªç ´å˜²è®½ï¼š${target.name}`);
        }
        else if (isLethal) {
            target = player;
            isHero = true;
            log(`ğŸ¤– AI æ— è§†éšä»ï¼Œç›´æ¥æ‰“è„¸ï¼`);
        }
        else if (highThreatMinions.length > 0) {
            target = highThreatMinions.sort((a, b) => b.atk - a.atk)[0];
            log(`ğŸ¤– AI å†³å®šè§£æ‰é«˜å¨èƒéšä»ï¼š${target.name}`);
        }
        else {
            target = player;
            isHero = true;
        }

        if (target) {
            const targetDomId = isHero ? 'player-hero-visual' : target.id;
            await animateCardCollision(minion.id, targetDomId);
            await performCombat(minion, target, isHero);
            minion.canAttack = false;
            checkGameOver();
            if (player.health <= 0) return;
        }
    }

    await sleep(500);
    log("AI å›åˆç»“æŸ");
    GAME_STATE.isPlayerTurn = true;
    startTurn();
}


function updateUI() {
    document.getElementById('player-health').innerText = GAME_STATE.player.health;
    document.getElementById('player-mana').innerText = `${GAME_STATE.player.currentMana}/${GAME_STATE.player.maxMana}`;
    document.getElementById('ai-health').innerText = GAME_STATE.ai.health;
    document.getElementById('ai-mana').innerText = `${GAME_STATE.ai.currentMana}/${GAME_STATE.ai.maxMana}`;

    renderAIHand();
    renderHand();
    renderField('player-field', GAME_STATE.player.field, true);
    renderField('ai-field', GAME_STATE.ai.field, false);
}

function renderAIHand() {
    const container = document.getElementById('ai-hand-visual');
    container.innerHTML = '';

    GAME_STATE.ai.hand.forEach(() => {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back';
        cardBack.style.backgroundImage = `url(${currentCardBack})`;
        container.appendChild(cardBack);
    });
}

function renderHand() {
    const handDiv = document.getElementById('player-hand');
    handDiv.innerHTML = '';
    GAME_STATE.player.hand.forEach(card => {
        const el = createCardElement(card);
        if (card.cost > GAME_STATE.player.currentMana) el.classList.add('disabled');

        // åŒºåˆ†æ³•æœ¯å’Œéšä»çš„äº¤äº’
        if (card.type === 'spell') {
            if (card.cost <= GAME_STATE.player.currentMana) {
                // å¦‚æœæ˜¯æŒ‡å‘æ€§æ³•æœ¯ï¼ˆå¦‚ä¼¤å®³ï¼‰ï¼Œä½¿ç”¨æ‹–æ‹½
                if (card.effect !== 'draw_2') {
                    el.onmousedown = (e) => startDrag(e, card.id, 'hand_spell');
                } else {
                    // å¦‚æœæ˜¯éæŒ‡å‘æ€§æ³•æœ¯ï¼ˆå¦‚æŠ½ç‰Œï¼‰ï¼Œä½¿ç”¨ç‚¹å‡»
                    el.onclick = () => playCard(card.id);
                }
            }
        } else {
            // éšä»ç‰Œç‚¹å‡»æ‰“å‡º
            el.onclick = () => playCard(card.id);
        }

        el.style.marginLeft = "-15px";
        handDiv.appendChild(el);
    });
}

function renderField(elementId, minions, isPlayer) {
    const fieldDiv = document.getElementById(elementId);
    fieldDiv.innerHTML = '';
    minions.forEach(card => {
        const el = createCardElement(card);
        el.classList.add('minion-on-field');

        if (!isPlayer) {
            el.classList.add('valid-target');
            el.setAttribute('data-target-type', 'minion');
            el.setAttribute('data-side', 'ai');
        }

        if (isPlayer && card.canAttack && GAME_STATE.isPlayerTurn) {
            el.classList.add('can-attack');
            el.onmousedown = (e) => startDrag(e, card.id, 'field');
        }

        fieldDiv.appendChild(el);
    });
}

// --- ä¿®æ”¹ï¼šæ·»åŠ æ‚¬åœé¢„è§ˆåŠŸèƒ½ ---
function showCardPreview(card) {
    const preview = document.getElementById('card-preview');
    preview.innerHTML = ''; // æ¸…ç©ºæ—§å†…å®¹
    
    // æ ¹æ®å¡ç‰Œç±»å‹è®¾ç½®æ ·å¼
    preview.className = ''; // é‡ç½®ç±»
    if (card.type === 'spell') preview.classList.add('spell-card');
    if (card.taunt) preview.classList.add('taunt-card');

    const imgUrl = card.img || 'https://via.placeholder.com/100x60?text=No+Image';
    
    let statsHtml = '';
    if (card.type !== 'spell') {
        statsHtml = `
            <div class="stat-bubble card-atk">${card.atk}</div>
            <div class="stat-bubble card-hp">${card.hp}</div>
        `;
    }

    let typeText = card.type === 'spell' ? "æ³•æœ¯" : "éšä»";
    if (card.taunt) typeText += " / å˜²è®½";
    if (card.deathrattle) typeText += " / äº¡è¯­";
    if (card.effect === 'aoe_1') typeText += " / æˆ˜å¼";

    preview.innerHTML = `
        <div class="stat-bubble card-cost">${card.cost}</div>
        <div class="card-img-container">
            <img src="${imgUrl}" class="card-img" style="width:100%; height:100%; object-fit:cover;">
        </div>
        <div class="card-text-area">
            <div class="card-name">${card.name}</div>
            <div style="font-size:12px; color:#777; margin-bottom:5px;">[${typeText}]</div>
            <div class="card-desc">${card.desc || "æ²¡æœ‰æè¿°"}</div>
        </div>
        ${statsHtml}
    `;

    preview.classList.add('visible');
}

function hideCardPreview() {
    document.getElementById('card-preview').classList.remove('visible');
}

function createCardElement(card) {
    const div = document.createElement('div');
    div.className = 'card';
    if (card.effect) div.classList.add('effect-card');
    if (card.deathrattle) div.classList.add('deathrattle-card');
    if (card.taunt) div.classList.add('taunt-card');
    if (card.type === 'spell') div.classList.add('spell-card'); // æ³•æœ¯æ ·å¼

    div.id = card.id;

    // --- æ–°å¢ï¼šç»‘å®šæ‚¬åœäº‹ä»¶ ---
    div.onmouseenter = () => showCardPreview(card);
    div.onmouseleave = () => hideCardPreview();

    const imgUrl = card.img || 'https://via.placeholder.com/100x60?text=No+Image';

    let extraIcon = '';
    if (card.deathrattle) {
        extraIcon = '<div class="deathrattle-icon">â˜ ï¸</div>';
    }

    // æ³•æœ¯ç‰Œä¸æ˜¾ç¤ºæ”»è¡€
    let statsHtml = '';
    if (card.type !== 'spell') {
        statsHtml = `
            <div class="stat-bubble card-atk">${card.atk}</div>
            <div class="stat-bubble card-hp">${card.hp}</div>
        `;
    }

    div.innerHTML = `
        <div class="stat-bubble card-cost">${card.cost}</div>
        <div class="card-img-container">
            <img src="${imgUrl}" class="card-img" alt="${card.name}">
        </div>
        <div class="card-text-area">
            <div class="card-name">${card.name}</div>
            <div class="card-desc">${card.desc || ""}</div>
        </div>
        ${extraIcon}
        ${statsHtml}
    `;
    return div;
}

function log(msg) {
    const logArea = document.getElementById('log-area');
    logArea.innerHTML += `<div>${msg}</div>`;
    logArea.scrollTop = logArea.scrollHeight;
}
function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

initGame();
</script>
</body>
</html>
